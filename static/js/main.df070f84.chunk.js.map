{"version":3,"sources":["constants/index.tsx","actions/index.tsx","types/index.tsx","utils/errors.ts","utils/Host.ts","utils/clipboard.ts","containers/Message.tsx","utils/mode.ts","utils/getWeb3.ts","utils/PermaURLUtil.tsx","containers/PermaURLForm.tsx","ModalDialog.tsx","containers/PermaURLModalDialog.tsx","containers/PermaURLOptions.tsx","external/react-spinner/react-spinner.js","App.tsx","reducers/index.tsx","serviceWorker.js","index.js"],"names":["FULL_URL_CHANGED","MODAL_ACCEPT_PRESSED","MODAL_CANCEL_PRESSED","ON_CUSTOM_HASH_CHECK_IS_RESOLVED","ON_HASH_INPUT_CHANGE","ON_SAVED_HASH_TO_ETHEREUM","ON_SENDING_HASH_TO_ETHEREUM","SET_BACKING_STORE","SET_OPTIONS_VISIBILITY","SHOW_METAMASK_DIALOG","UPDATE_MESSAGE","UPDATE_WEB3_STATE","updateMessage","messageKind","type","constants","kind","MessageKind","MissingWeb3Error","_Error","message","_this","Object","classCallCheck","this","possibleConstructorReturn","getPrototypeOf","call","setPrototypeOf","assertThisInitialized","constructor","prototype","inherits","wrapNativeSuper","Error","initWeb3State","accounts","contract","web3","BackingStore","initFormState","customHash","fullURL","isSubmitEnabled","customHashTimeoutID","undefined","initOptionsState","isVisible","backingStore","ROPSTEN","initialState","formState","isMetamaskDialogVisible","isSpinnerNeeded","NONE","optionsState","savedHash","web3State","getHashedURL","hashedURL","window","location","protocol","host","MAINNET","getPrefix","getBackingStoreFromPrefix","hash","Message","react_default","a","createElement","className","getMessageInternals","props","CHECKING_AVAILABILITY","HASH_TAKEN_TRY_ANOTHER","SHORT_URL_PREVIEW","EMPTY_URL","INSTALL_METAMASK","href","rel","target","SENDING_TO_ETHEREUM","encouragements","randIndex","Math","floor","random","length","getEncouragement","HASHED_URL_WITH_COPY","resultHashedURL","onClick","str","el","document","value","setAttribute","style","position","left","body","appendChild","selection","getSelection","selected","rangeCount","getRangeAt","select","execCommand","removeChild","removeAllRanges","addRange","copyToClipboard","FAILED_TO_GENERATE_HASH","ERROR_SENDING_TO_ETHEREUM","Component","connect","Mode","state","dispatch","getWeb3ReadOnlyAsync","_ref2","asyncToGenerator","regenerator_default","mark","_callee2","mode","server","provider","wrap","_context2","prev","next","HDWalletProvider","abrupt","Web3","stop","_x","apply","arguments","getWeb3Async","_ref3","_callee3","_web","_web2","_context3","ethereum","enable","LOCALHOST","providers","HttpProvider","_x2","Permissions","READ_ONLY","READ_WRITE","ContractAddress","MAINNET_ADDRESS","ROPSTEN_ADDRESS","getFullURLFromHash","_getFullURLFromHash","_callee","components","fullURLRaw","_context","getWeb3Components","sent","get","utils","asciiToHex","toAscii","_x3","_x4","_getWeb3Components","permissions","Contract","instance","getModeFromBackingStore","t0","eth","getAccounts","truffleContract","PermaURLStorageContract","setProvider","currentProvider","at","t1","console","log","PermaURLForm","onSubmit","bind","onChange","onFullURLChange","placeholder","onHashInputChange","disabled","e","preventDefault","currentTarget","showMetamaskDialog","clearTimeout","timeoutID","setTimeout","onHashInputChangeImpl","isHashTaken","isTaken","onCustomHashCheckIsResolved","payload","actions","newFullURL","text","newMessage","ModalDialog","nextProps","setState","overlayStyle","display","onOverlayClicked","children","onAcceptButtonClicked","onCancelButtonClicked","closeDialog","dialogShouldClose","PermaURLModalDialog","src_ModalDialog_0","onDialogShouldClose","PermaURLOptions","doHideOptions","onStorageOptionChange","doShowOptions","setOptionsVisibility","setBackingStore","doShow","newStore","Spinner","bars","i","barStyle","WebkitAnimationDelay","animationDelay","WebkitTransform","transform","push","key","assign","React","App","title","locationHash","substring","url","match","containers_PermaURLModalDialog","onMetamaskDialogAcceptClicked","onMetamaskDialogShouldClose","containers_PermaURLForm","containers_PermaURLOptions","containers_Message","react_spinner_react_spinner","initWeb3","hashFullURL","autogeneratedHash","saveToEthereum","updateWeb3State","sha256","bigHash","totalAttempts","fromAscii","msgUint8","TextEncoder","encode","Date","now","crypto","subtle","digest","hashBuffer","hashArray","Array","from","Uint8Array","hashHex","map","b","toString","slice","join","onSendingHashToEthereum","set","error","_context6","onSavedHashToEthereum","newWeb3State","permaURLAppReducers","combineReducers","action","objectSpread","action2","actn","Boolean","hostname","store","createStore","ReactDOM","render","es","src_App_0","getElementById","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"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","file":"static/js/main.df070f84.chunk.js","sourcesContent":["\n// action types\nexport const FULL_URL_CHANGED = 'FULL_URL_CHANGED';\nexport type FULL_URL_CHANGED = typeof FULL_URL_CHANGED;\n\nexport const MODAL_ACCEPT_PRESSED = 'MODAL_ACCEPT_PRESSED';\nexport type MODAL_ACCEPT_PRESSED = typeof MODAL_ACCEPT_PRESSED;\n\nexport const MODAL_CANCEL_PRESSED = 'MODAL_CANCEL_PRESSED';\nexport type MODAL_CANCEL_PRESSED = typeof MODAL_CANCEL_PRESSED;\n\nexport const ON_CUSTOM_HASH_CHECK_IS_RESOLVED = 'ON_CUSTOM_HASH_CHECK_IS_RESOLVED';\nexport type ON_CUSTOM_HASH_CHECK_IS_RESOLVED = typeof ON_CUSTOM_HASH_CHECK_IS_RESOLVED;\n\nexport const ON_HASH_INPUT_CHANGE = 'ON_HASH_INPUT_CHANGE';\nexport type ON_HASH_INPUT_CHANGE = typeof ON_HASH_INPUT_CHANGE;\n\nexport const ON_SAVED_HASH_TO_ETHEREUM = 'ON_SAVED_HASH_TO_ETHEREUM';\nexport type ON_SAVED_HASH_TO_ETHEREUM = typeof ON_SAVED_HASH_TO_ETHEREUM;\n\nexport const ON_SENDING_HASH_TO_ETHEREUM = 'ON_SENDING_HASH_TO_ETHEREUM';\nexport type ON_SENDING_HASH_TO_ETHEREUM = typeof ON_SENDING_HASH_TO_ETHEREUM;\n\nexport const SET_BACKING_STORE = 'SET_BACKING_STORE';\nexport type SET_BACKING_STORE = typeof SET_BACKING_STORE;\n\nexport const SET_OPTIONS_VISIBILITY = 'SET_OPTIONS_VISIBILITY';\nexport type SET_OPTIONS_VISIBILITY = typeof SET_OPTIONS_VISIBILITY;\n\nexport const SHOW_METAMASK_DIALOG = 'SHOW_METAMASK_DIALOG';\nexport type SHOW_METAMASK_DIALOG = typeof SHOW_METAMASK_DIALOG;\n\nexport const UPDATE_MESSAGE = 'UPDATE_MESSAGE';\nexport type UPDATE_MESSAGE = typeof UPDATE_MESSAGE;\n\nexport const UPDATE_WEB3_STATE = 'UPDATE_WEB3_STATE';\nexport type UPDATE_WEB3_STATE = typeof UPDATE_WEB3_STATE;\n","import * as constants from \"../constants\";\nimport { BackingStore, MessageKind, Web3State } from \"../types\";\n\n// Style note:\n// since all actions have the type attribute, it is specified on top\n// then the rest of the attributes are in alphabetical order\n\nexport interface FullURLChangedAction {\n  type: string,\n  text: string,\n}\nexport function fullURLChanged(newFullURL: string): FullURLChangedAction {\n  return { type: constants.FULL_URL_CHANGED, text: newFullURL };\n}\n\nexport interface ModalAcceptClicked {\n  type: string\n}\nexport function modalAcceptClicked(): ModalAcceptClicked {\n  return { type: constants.MODAL_ACCEPT_PRESSED };\n}\n\nexport interface ModalCancelClicked {\n  type: string\n}\nexport function modalCancelClicked(): ModalCancelClicked {\n  return { type: constants.MODAL_CANCEL_PRESSED };\n}\n\nexport interface ShowMetamaskDialog {\n  type: string\n}\nexport function showMetamaskDialog(): ShowMetamaskDialog {\n  return { type: constants.SHOW_METAMASK_DIALOG };\n}\n\nexport interface UpdateWeb3StateAction {\n  type: string,\n  web3State: Web3State,\n}\nexport function updateWeb3State(newWeb3State: Web3State): UpdateWeb3StateAction {\n  return { type: constants.UPDATE_WEB3_STATE, web3State: newWeb3State };\n}\n\nexport interface UpdateMessageAction {\n  type: string,\n  kind: MessageKind,\n}\nexport function updateMessage(messageKind: MessageKind): UpdateMessageAction {\n  return { type: constants.UPDATE_MESSAGE, kind: messageKind };\n}\n\nexport interface OnHashInputChangeAction {\n  type: string,\n  payload: {\n    customHash: string,\n    customHashTimeoutID: ReturnType<typeof setTimeout> | undefined,\n    isSpinnerNeeded: boolean,\n    isSubmitEnabled: boolean,\n    messageKind: MessageKind,\n  }\n}\nexport function onHashInputChange(\n  payload: {\n    customHash: string,\n    customHashTimeoutID: ReturnType<typeof setTimeout> | undefined,\n    isSpinnerNeeded: boolean,\n    isSubmitEnabled: boolean,\n    messageKind: MessageKind,\n  }\n): OnHashInputChangeAction {\n  return {\n    type: constants.ON_HASH_INPUT_CHANGE,\n    payload: payload,\n  }\n}\n\nexport interface OnCustomHashCheckIsResolvedAction {\n  type: string,\n  payload: {\n    customHash: string,\n    customHashTimeoutID: ReturnType<typeof setTimeout> | undefined,\n    isSpinnerNeeded: boolean,\n    isSubmitEnabled: boolean,\n    messageKind: MessageKind,\n  }\n}\nexport function onCustomHashCheckIsResolved(\n  payload: {\n    customHash: string,\n    customHashTimeoutID: ReturnType<typeof setTimeout> | undefined,\n    isSpinnerNeeded: boolean,\n    isSubmitEnabled: boolean,\n    messageKind: MessageKind,\n  }\n): OnCustomHashCheckIsResolvedAction {\n  return {\n    type: constants.ON_CUSTOM_HASH_CHECK_IS_RESOLVED,\n    payload: payload,\n  }\n}\n\nexport interface OnSendingHashToEthereumAction {\n  type: string,\n  payload: {\n    isSpinnerNeeded: boolean,\n    messageKind: MessageKind,\n  }\n}\nexport function onSendingHashToEthereum(\n  payload: {\n    isSpinnerNeeded: boolean,\n    messageKind: MessageKind,\n  }\n): OnSendingHashToEthereumAction {\n  return {\n    type: constants.ON_SENDING_HASH_TO_ETHEREUM,\n    payload: payload,\n  }\n}\n\nexport interface OnSavedHashToEthereumAction {\n  type: string,\n  payload: {\n    isSpinnerNeeded: boolean,\n    messageKind: MessageKind,\n    savedHash: string,\n  }\n}\nexport function onSavedHashToEthereum(\n  payload: {\n    isSpinnerNeeded: boolean,\n    messageKind: MessageKind,\n    savedHash: string,\n  }\n): OnSavedHashToEthereumAction {\n  return {\n    type: constants.ON_SAVED_HASH_TO_ETHEREUM,\n    payload: payload\n  }\n}\n\nexport interface SetOptionsVisibilityAction {\n  type: string,\n  doShow: boolean,\n}\nexport function setOptionsVisibility(\n  doShow: boolean,\n): SetOptionsVisibilityAction {\n  return {\n    type: constants.SET_OPTIONS_VISIBILITY,\n    doShow: doShow,\n  }\n}\n\nexport interface SetBackingStoreAction {\n  type: string,\n  newStore: BackingStore,\n}\nexport function setBackingStore(\n  newStore: BackingStore,\n): SetBackingStoreAction {\n  return {\n    type: constants.SET_BACKING_STORE,\n    newStore: newStore,\n  }\n}\n\nexport type PermaURLAction =\n  FullURLChangedAction |\n  ModalAcceptClicked |\n  ModalCancelClicked |\n  OnCustomHashCheckIsResolvedAction |\n  OnHashInputChangeAction |\n  OnSavedHashToEthereumAction |\n  OnSendingHashToEthereumAction |\n  SetBackingStoreAction |\n  SetOptionsVisibilityAction |\n  ShowMetamaskDialog |\n  UpdateMessageAction |\n  UpdateWeb3StateAction;\n","export interface Web3State {\n  accounts: null | any,\n  contract: null | any,\n  web3: null | any,\n}\n\nexport const initWeb3State: Web3State = {\n  accounts: null,\n  contract: null,\n  web3 : null,\n}\n\nexport enum MessageKind {\n  CHECKING_AVAILABILITY = 'CHECKING_AVAILABILITY',\n  EMPTY_URL = 'EMPTY_URL',\n  ERROR_SENDING_TO_ETHEREUM = 'ERROR_SENDING_TO_ETHEREUM',\n  FAILED_TO_GENERATE_HASH = 'FAILED_TO_GENERATE_HASH',\n  INSTALL_METAMASK= 'INSTALL_METAMASK',\n  HASH_TAKEN_TRY_ANOTHER = 'HASH_TAKEN_TRY_ANOTHER',\n  HASHED_URL_WITH_COPY = 'HASHED_URL_WITH_COPY',\n  NONE = 'NONE',\n  SENDING_TO_ETHEREUM = 'SENDING_TO_ETHEREUM',\n  SHORT_URL_PREVIEW = 'SHORT_URL_PREVIEW',\n}\n\nexport interface FormState {\n  customHash: string,\n  fullURL: string,\n  isSubmitEnabled: boolean,\n  customHashTimeoutID: ReturnType<typeof setTimeout> | undefined,\n}\n\nexport const initFormState: FormState = {\n  customHash: '',\n  fullURL: '',\n  isSubmitEnabled: true,\n  customHashTimeoutID: undefined,\n}\n\nexport enum BackingStore {\n  MAINNET = 'MAINNET',\n  ROPSTEN = 'ROPSTEN',\n}\n\nexport interface OptionsState {\n  isVisible: boolean\n  backingStore: BackingStore,\n}\n\nexport const initOptionsState: OptionsState = {\n  isVisible: false,\n  backingStore: BackingStore.ROPSTEN,\n}\n\nexport interface StoreState {\n  formState: FormState,\n  isMetamaskDialogVisible: boolean,\n  isSpinnerNeeded: boolean,\n  messageKind: MessageKind,\n  optionsState: OptionsState,\n  savedHash: string | null,\n  web3State: Web3State,\n}\n\nexport const initialState: StoreState = {\n  formState: initFormState,\n  isMetamaskDialogVisible: false,\n  isSpinnerNeeded: false,\n  messageKind: MessageKind.NONE,\n  optionsState: initOptionsState,\n  savedHash: null,\n  web3State: initWeb3State,\n}\n","// reference: https://stackoverflow.com/a/27724419\n\nexport class MissingWeb3Error extends Error {\n  constructor(message: string) {\n    super(message);\n    Object.setPrototypeOf(this, new.target.prototype); // restore\n  }\n}\n","\nimport { BackingStore } from \"../types/\";\n\nexport function getHashedURL(hashedURL: string, backingStore: BackingStore): string {\n  return getHostname() + \"/#\" + getPrefix(backingStore) + \"/\" + hashedURL;\n}\n\nfunction getPrefix(backingStore: BackingStore): string {\n  switch (backingStore) {\n    case BackingStore.MAINNET:\n      return \"m\";\n    case BackingStore.ROPSTEN:\n      return \"r\";\n  }\n}\n\nexport function getBackingStoreFromPrefix(hash: string): BackingStore | null {\n\n  const firstChar = hash[1];\n  switch (firstChar) {\n    case 'm':\n      return BackingStore.MAINNET;\n    case 'r':\n      return BackingStore.ROPSTEN;\n    default:\n      return null;\n  }\n}\n\nfunction getHostname(): string {\n\treturn window.location.protocol + \"//\" + window.location.host;\n}\n\nexport function getURLForRedirect(url: string): string {\n\tif (url.match(/^http?:\\/\\//i) || url.match(/^https?:\\/\\//i)) {\n\t\treturn url;\n\t}\n\treturn 'https://' + url;\n}\n","// credit: https://hackernoon.com/copying-text-to-clipboard-with-javascript-df4d4988697f\nexport const copyToClipboard = (str: string) => {\n  const el = document.createElement('textarea');  // Create a <textarea> element\n  el.value = str;                                 // Set its value to the string that you want copied\n  el.setAttribute('readonly', '');                // Make it readonly to be tamper-proof\n  el.style.position = 'absolute';\n  el.style.left = '-9999px';                      // Move outside the screen to make it invisible\n  document.body.appendChild(el);                  // Append the <textarea> element to the HTML document\n\n  const selection = document.getSelection();\n  const selected =\n    selection !== null &&\n    selection.rangeCount > 0        // Check if there is any content selected previously\n      ? selection.getRangeAt(0)     // Store selection if found\n      : false;                                    // Mark as false to know no selection existed before\n  el.select();                                    // Select the <textarea> content\n  document.execCommand('copy');                   // Copy - only works as a result of a user action (e.g. click events)\n  document.body.removeChild(el);                  // Remove the <textarea> element\n  if (selected && selection !== null) {             // If a selection existed before copying\n    selection.removeAllRanges();    // Unselect everything on the HTML document\n    selection.addRange(selected);   // Restore the original selection\n  }\n};\n","import React, { Component } from \"react\";\nimport { connect } from 'react-redux';\nimport { Dispatch } from 'redux';\n\nimport * as actions from \"../actions/\";\nimport { copyToClipboard } from \"../utils/clipboard\";\nimport { getHashedURL } from \"../utils/Host\";\nimport { BackingStore, MessageKind, StoreState } from \"../types\";\n\ninterface MessageProps {\n  backingStore: BackingStore,\n  customHash: string,\n  messageKind: MessageKind,\n  savedHash: string | null,\n}\n\ninterface MessageState {\n}\n\nclass Message extends Component<MessageProps, MessageState> {\n  render() {\n    return (\n\t\t  <div className=\"Message-container\"> {this.getMessageInternals()} </div>\n    );\n  }\n\n  getMessageInternals() {\n    switch (this.props.messageKind) {\n      case MessageKind.CHECKING_AVAILABILITY:\n        return (<p> checking if /{this.props.customHash} is available.</p>);\n\n      case MessageKind.HASH_TAKEN_TRY_ANOTHER:\n        return (<p>/{this.props.customHash} has already been taken. Please try another one.</p>);\n\n      case MessageKind.SHORT_URL_PREVIEW:\n        return (\n          <p>\n            your shortened url will be:\n            <br />\n            {getHashedURL(this.props.customHash, this.props.backingStore)}\n            <br />\n          </p>\n        );\n\n      case MessageKind.EMPTY_URL:\n        return (<p>yo! please enter a full url in the box.</p>);\n\n      case MessageKind.INSTALL_METAMASK:\n        return (\n            <p>\n              Alas, looks like you will need to\n              install <a href=\"https://metamask.io\" rel=\"noopener noreferrer\" target=\"_blank\">Metamask</a>.\n              This lets us save your URL securely.\n            </p>\n          );\n\n      case MessageKind.SENDING_TO_ETHEREUM:\n        return (<p>Alrighty, saving on ethereum. Will take around 20 seconds. {getEncouragement()}</p>);\n\n      case MessageKind.HASHED_URL_WITH_COPY:\n        const resultHashedURL = this.props.savedHash === null ? '' : getHashedURL(this.props.savedHash, this.props.backingStore);\n        return (\n          <p>\n            {resultHashedURL}\n            &nbsp; &nbsp; &nbsp; &nbsp; (\n            <a\n              className=\"App-link\"\n              onClick={() => copyToClipboard(resultHashedURL)}\n              >\n              copy\n            </a>\n            {')'}\n          </p>\n        );\n\n      case MessageKind.FAILED_TO_GENERATE_HASH:\n        return (<p>\"Failed to generate a suitable hash! Bummer.\"</p>);\n\n      case MessageKind.ERROR_SENDING_TO_ETHEREUM:\n        return (<p>\"There was an error saving on ethereum. Sad puppy :-(\"</p>);\n\n      case MessageKind.NONE:\n      default:\n        return null;\n    }\n  }\n}\n\nfunction getEncouragement(): string {\n\t\tconst encouragements = [\n\t\t\t\"Be patient, and hold your horses!\",\n\t\t\t\"Close your eyes and think about your first true love!\",\n\t\t\t\"A good time to step back, and do some stretches!\",\n\t\t\t\"But if you stare real hard, it'll happen faster! Promise ;-)\",\n\t\t\t\"Close your eyes, and meditate on the sounds around you!\",\n\t\t\t\"Close your eyes, and meditate on your breathing!\",\n\t\t\t\"A test of your will power is commencing. Try your best to not switch to reddit or twitter!\"\n\t\t];\n\t\tconst randIndex = Math.floor(Math.random() * encouragements.length);\n\t\treturn encouragements[randIndex];\n\t}\n\nfunction mapStateToProps(state: StoreState) {\n  return {\n    backingStore: state.optionsState.backingStore,\n    customHash: state.formState.customHash,\n    savedHash: state.savedHash,\n    messageKind: state.messageKind,\n  };\n}\n\nfunction mapDispatchToProps(dispatch: Dispatch<actions.PermaURLAction>) {\n  return {};\n}\n\nexport default connect(mapStateToProps, mapDispatchToProps)(Message);\n","// TODO savil consolidate with BackingStore?\nexport enum Mode {\n  MAINNET = \"mainnet\",\n  ROPSTEN = \"ropsten\",\n  LOCALHOST = \"localhost\",\n}\n\nexport default Mode;\n","import Web3 from \"web3\";\nimport HDWalletProvider from \"truffle-hdwallet-provider\";\nimport { Mode } from \"./mode\";\nimport { MissingWeb3Error } from \"./errors\";\n\nexport const getWeb3 = (mode: string) =>\n  new Promise((resolve, reject) => {\n    // Wait for loading completion to avoid race conditions with web3 injection timing.\n    window.addEventListener(\"load\", async () => {\n\t\t\ttry {\n\t\t\t\tconst web3 = await getWeb3Async(mode);\n\t\t\t\tresolve(web3);\n\t\t\t} catch (error) {\n\t\t\t\treject(error);\n\t\t\t}\n   });\n  });\n\nexport const getWeb3ReadOnlyAsync = async(mode: string) => {\n    // just some rando mnemonic. It has no money in it, and is used\n    // for making read-only queries to infura/ethereum.\n    const mnemonic = \"truth project dilemma ramp hint dream custom produce country skate search view\";\n    const server = mode === Mode.ROPSTEN\n      ? \"https://ropsten.infura.io/v3/cb7d847147034deab366ab3169602261\"\n      : \"https://mainnet.infura.io/v3/cb7d847147034deab366ab3169602261\";\n\n    const provider = new HDWalletProvider(mnemonic, server);\n    return new Web3(provider);\n}\n\nexport const getWeb3Async = async (mode: string) => {\n\n  // Modern dapp browsers...\n\tif ((window as any).ethereum) {\n\t\tconst web3 = new Web3((window as any).ethereum);\n\n    // Request account access if needed\n    await (window as any).ethereum.enable();\n\n\t\t// Accounts now exposed\n\t\treturn web3;\n\t}\n\t// Legacy dapp browsers...\n\telse if ((window as any).web3) {\n\t\t// Use Mist/MetaMask's provider.\n\t\tconst web3 = (window as any).web3;\n\t\treturn web3;\n\t}\n\t// Fallback to localhost; use dev console port by default...\n\telse if (mode === Mode.LOCALHOST) {\n\t\tconst provider = new Web3.providers.HttpProvider(\n\t\t\t\"http://127.0.0.1:9545\"\n\t\t);\n\t\tconst web3 = new Web3(provider);\n\t\treturn web3;\n\t} else {\n    throw new MissingWeb3Error(\"no web3 provider found\");\n  }\n}\n\nexport default getWeb3;\n","import truffleContract from \"truffle-contract\";\n\nimport { Mode } from \"./mode\";\nimport { BackingStore, Web3State } from \"../types\";\nimport { getWeb3Async, getWeb3ReadOnlyAsync } from \"./getWeb3\";\nimport PermaURLStorageContract from \"../contracts/PermaURLStorage.json\";\n\n//const MODE = Mode.MAINNET;\nconst MODE = Mode.ROPSTEN;\n\nexport const Permissions = {\n  READ_ONLY: \"read_only\",\n  READ_WRITE: \"read_write\"\n};\n\nconst ContractAddress = {\n  MAINNET_ADDRESS: \"0xf0625cF19647fe7689Bc7b0B8C54aFFb71d94cb3\",\n  ROPSTEN_ADDRESS: \"0x0c72eb3f9ad6c762c17adae11ffd2458ce533ef4\"\n};\n\nexport async function getFullURLFromHash(hash: string, backingStore: BackingStore): Promise<string | null> {\n  const components = await getWeb3Components(Permissions.READ_ONLY, backingStore);\n  if (components === null) {\n    return null;\n  }\n\n  const fullURLRaw = await components.contract.get.call(\n    components.web3.utils.asciiToHex(hash)\n  );\n  if (fullURLRaw === null) {\n    return null;\n  }\n  return components.web3.utils.toAscii(fullURLRaw);\n}\n\nexport async function getWeb3Components(\n  permissions: string,\n  backingStore: BackingStore,\n): Promise<Web3State> {\n  let mode = getModeFromBackingStore(backingStore);\n  try {\n    // Get network provider and web3 instance.\n    const web3 = (permissions === Permissions.READ_ONLY)\n      ? await getWeb3ReadOnlyAsync(mode)\n      : await getWeb3Async(mode);\n\n    // Use web3 to get the user's accounts.\n    let accounts = null;\n    if (permissions === Permissions.READ_WRITE) {\n      accounts = await web3.eth.getAccounts();\n    }\n\n    // Get the contract instance.\n    const Contract = truffleContract(PermaURLStorageContract);\n    Contract.setProvider(web3.currentProvider);\n\n    let instance = null;\n    if (mode === Mode.MAINNET) {\n      instance = await Contract.at(ContractAddress.MAINNET_ADDRESS);\n    } else {\n      instance = await Contract.at(ContractAddress.ROPSTEN_ADDRESS);\n    }\n\n    return { web3, accounts, contract : instance };\n\n  } catch (error) {\n    // Catch any errors for any of the above operations.\n    console.log(error);\n    throw error;\n  }\n}\n\nfunction getModeFromBackingStore(\n  backingStore: BackingStore,\n): Mode {\n  switch (backingStore) {\n    case BackingStore.MAINNET:\n      return Mode.MAINNET;\n    case BackingStore.ROPSTEN:\n      return Mode.ROPSTEN;\n  }\n}\n","import React, { Component } from \"react\";\nimport { connect } from 'react-redux';\nimport { Dispatch } from 'redux';\n\nimport * as actions from \"../actions/\";\nimport { getFullURLFromHash } from \"../utils/PermaURLUtil\";\nimport { BackingStore, FormState, MessageKind, StoreState } from \"../types\";\n\ninterface PermaURLFormProps {\n  backingStore: BackingStore,\n  formState: FormState,\n  onFullURLChange: (newFullURL: string) => void,\n  onHashInputChange:\n    (payload: {\n      customHash: string,\n      customHashTimeoutID: ReturnType<typeof setTimeout> | undefined,\n      isSpinnerNeeded: boolean,\n      isSubmitEnabled: boolean,\n      messageKind: MessageKind,\n    }) => void,\n  onCustomHashCheckIsResolved:\n    (payload: {\n      customHash: string,\n      customHashTimeoutID: ReturnType<typeof setTimeout> | undefined,\n      isSpinnerNeeded: boolean,\n      isSubmitEnabled: boolean,\n      messageKind: MessageKind,\n    }) => void,\n  showMetamaskDialog: () => void,\n  updateMessage: (newMessage: MessageKind) => void,\n}\n\ninterface PermaURLFormState {\n}\n\nclass PermaURLForm extends Component<PermaURLFormProps, PermaURLFormState> {\n  render() {\n    return (\n      <form onSubmit={this.onSubmit.bind(this)}>\n        <input\n          className=\"fullURLInput\"\n          onChange={this.onFullURLChange.bind(this)}\n          placeholder=\"enter full url here\"\n          type=\"text\"\n        />\n        <input\n          className=\"customHashInput\"\n          onChange={this.onHashInputChange.bind(this)}\n          placeholder=\"(optional) specify your vanity url\"\n          type=\"text\"\n        />\n        <br />\n        <input\n          disabled={!this.props.formState.isSubmitEnabled}\n          className=\"fullURLSubmit\"\n          type=\"submit\"\n          value=\"submit\"\n        />\n      </form>\n    );\n  }\n\n\tonFullURLChange(e: React.FormEvent<HTMLInputElement>) {\n\t\te.preventDefault();\n    this.props.onFullURLChange(e.currentTarget.value);\n\t}\n\n\tasync onSubmit(e: React.FormEvent) {\n\t\te.preventDefault();\n\t\tif (this.props.formState.fullURL === '') {\n      this.props.updateMessage(MessageKind.EMPTY_URL);\n\t\t\treturn;\n\t\t}\n\n    this.props.showMetamaskDialog();\n  }\n\n  async onHashInputChange(e: React.FormEvent<HTMLInputElement>) {\n    e.preventDefault();\n    if (this.props.formState.customHashTimeoutID !== undefined) {\n      clearTimeout(this.props.formState.customHashTimeoutID);\n    }\n\n    const customHash = e.currentTarget.value;\n    if (customHash === '') {\n      this.props.onHashInputChange({\n        customHash: customHash,\n        customHashTimeoutID: undefined,\n        isSpinnerNeeded: false,\n        isSubmitEnabled: true,\n        messageKind: MessageKind.NONE,\n      });\n      return;\n    }\n\n    const timeoutID = setTimeout(\n      async () => this.onHashInputChangeImpl(customHash),\n      200, // milliseconds\n    );\n    this.props.onHashInputChange({\n      customHash: customHash,\n      customHashTimeoutID: timeoutID,\n      isSpinnerNeeded: true,\n      isSubmitEnabled: false,\n      messageKind: MessageKind.CHECKING_AVAILABILITY,\n    });\n    return;\n  }\n\n  async onHashInputChangeImpl(customHash: string) {\n\n    var timeoutID = this.props.formState.customHashTimeoutID;\n    if (timeoutID === undefined) {\n      return; // abort if already cancelled.\n    }\n\n    let isTaken = await this.isHashTaken(customHash);\n\n    if (timeoutID !== this.props.formState.customHashTimeoutID) {\n      return; // abort if customHashTimeoutID changed while waiting\n    }\n\n    // check if hash is taken\n    // if taken, show message and disable submit\n    if (isTaken) {\n      this.props.onCustomHashCheckIsResolved({\n        customHash: customHash,\n        customHashTimeoutID: undefined,\n        isSpinnerNeeded: false,\n        isSubmitEnabled: false,\n        messageKind: MessageKind.HASH_TAKEN_TRY_ANOTHER,\n      });\n      return;\n    }\n\n    // if not taken, then show preview\n    this.props.onCustomHashCheckIsResolved({\n      customHash: customHash,\n      customHashTimeoutID: undefined,\n      isSpinnerNeeded: false,\n      isSubmitEnabled: true,\n      messageKind: MessageKind.SHORT_URL_PREVIEW,\n    });\n  }\n\n  async isHashTaken(hash: string): Promise<boolean> {\n    return (await getFullURLFromHash(hash, this.props.backingStore)) !== null;\n  }\n}\n\nfunction mapStateToProps(state: StoreState) {\n  return {\n    backingStore: state.optionsState.backingStore,\n    formState: state.formState,\n  };\n}\n\nfunction mapDispatchToProps(dispatch: Dispatch<actions.PermaURLAction>) {\n  return {\n\n    onCustomHashCheckIsResolved:\n      (payload: {\n        customHash: string,\n        customHashTimeoutID: ReturnType<typeof setTimeout> | undefined,\n        isSpinnerNeeded: boolean,\n        isSubmitEnabled: boolean,\n        messageKind: MessageKind,\n      }) => dispatch(actions.onCustomHashCheckIsResolved(payload)),\n\n    onFullURLChange:\n      (newFullURL: string) => dispatch(actions.fullURLChanged(newFullURL)),\n\n    onHashInputChange:\n      (payload: {\n        customHash: string,\n        customHashTimeoutID: ReturnType<typeof setTimeout> | undefined,\n        isSpinnerNeeded: boolean,\n        isSubmitEnabled: boolean,\n        messageKind: MessageKind,\n      }) => dispatch(actions.onHashInputChange(payload)),\n\n    showMetamaskDialog: () => dispatch(actions.showMetamaskDialog()),\n    updateMessage:\n      (newMessage: MessageKind) => dispatch(actions.updateMessage(newMessage)),\n  };\n}\n\nexport default connect(mapStateToProps, mapDispatchToProps)(PermaURLForm);\n","import React, { Component } from \"react\";\n\nimport \"./ModalDialog.css\";\n\ninterface ModalDialogState {\n  isVisible: boolean;\n}\n\ninterface ModalDialogProps {\n  isVisible: boolean;\n  onAcceptButtonClicked(): void;\n  dialogShouldClose(): void;\n}\n\n// inspiration from: https://github.com/marcio/react-skylight\nclass ModalDialog extends Component<ModalDialogProps, ModalDialogState> {\n  state = {\n    isVisible: this.props.isVisible\n  };\n\n  componentWillReceiveProps(nextProps: ModalDialogProps) {\n    if (nextProps.isVisible !== this.props.isVisible) {\n      this.setState({ isVisible: nextProps.isVisible });\n    }\n  }\n\n  render() {\n    const overlayStyle = {\n      display: this.state.isVisible ? \"block\" : \"none\"\n    };\n\n    return (\n      <div\n        className=\"ModalDialogOverlay\"\n        onClick={this.onOverlayClicked.bind(this)}\n        style={overlayStyle}\n      >\n        <div className=\"ModalDialogContainer\">\n          <div>{this.props.children}</div>\n          <button\n            className=\"Accept\"\n            onClick={this.onAcceptButtonClicked.bind(this)}\n          >\n            Sounds good\n          </button>\n          <button onClick={this.onCancelButtonClicked.bind(this)}>\n            Cancel\n          </button>\n        </div>\n      </div>\n    );\n  }\n\n  onOverlayClicked(e: React.SyntheticEvent) {\n    this.closeDialog(e);\n  }\n\n  onCancelButtonClicked(e: React.SyntheticEvent) {\n    this.closeDialog(e);\n  }\n\n  onAcceptButtonClicked(e: React.SyntheticEvent) {\n    this.closeDialog(e);\n    this.props.onAcceptButtonClicked();\n  }\n\n  closeDialog(e: React.SyntheticEvent) {\n    e.preventDefault();\n    this.props.dialogShouldClose();\n  }\n}\n\nexport default ModalDialog;\n","import React, { Component} from 'react';\nimport { connect } from 'react-redux';\n\nimport ModalDialog from \"./../ModalDialog\"\n\ninterface PermaURLModalDialogProps {\n  isVisible: boolean,\n  onAcceptButtonClicked: () => void,\n  onDialogShouldClose: () => void\n}\n\nclass PermaURLModalDialog extends Component<PermaURLModalDialogProps, {}> {\n  render() {\n    return (\n      <ModalDialog\n        isVisible={this.props.isVisible}\n        onAcceptButtonClicked={this.props.onAcceptButtonClicked}\n        dialogShouldClose={this.props.onDialogShouldClose}\n      >\n        Next, Metamask will open a dialog.\n        <br />\n        <br />\n        You will be asked to confirm the transaction for saving your URL to ethereum's blockchain.\n        <br />\n        <br />\n      </ModalDialog>\n    );\n  };\n}\n\nexport default connect()(PermaURLModalDialog);\n","import React, { Component } from \"react\";\nimport { connect } from \"react-redux\";\nimport { Dispatch } from \"redux\";\n\nimport * as actions from \"../actions/\";\nimport { BackingStore, OptionsState, StoreState } from \"../types/\";\n\ninterface PermaURLOptionsProps {\n  optionsState: OptionsState,\n  setBackingStore: (newStore: BackingStore) => void,\n  setOptionsVisibility: (doShow: boolean) => void,\n}\n\ninterface PermaURLOptionsState {\n}\n\nclass PermaURLOptions extends Component<PermaURLOptionsProps, PermaURLOptionsState> {\n  render() {\n    if (!this.props.optionsState.isVisible) {\n      return (\n        <div>\n          <a onClick={this.doShowOptions.bind(this)}> Show Options </a>\n        </div>\n      );\n    }\n\n    return (\n      <div>\n        <a onClick={this.doHideOptions.bind(this)}> Hide Options </a>\n        <div>\n          Storage:\n          <select onChange={this.onStorageOptionChange.bind(this)}>\n            <option value={BackingStore.MAINNET}>Mainnet (real ethereum) </option>\n            <option selected={true} value={BackingStore.ROPSTEN}>Ropsten (fake ethereum, costs nothing to try) </option>\n          </select>\n        </div>\n      </div>\n    );\n  }\n\n  doShowOptions(e: React.SyntheticEvent) {\n    e.preventDefault();\n    this.props.setOptionsVisibility(true);\n  }\n\n  doHideOptions(e: React.SyntheticEvent) {\n    e.preventDefault();\n    this.props.setOptionsVisibility(false);\n  }\n\n  onStorageOptionChange(e: React.ChangeEvent<HTMLSelectElement>) {\n    e.preventDefault();\n    this.props.setBackingStore(e.currentTarget.value as BackingStore);\n  }\n}\n\nfunction mapDispatchToProps(dispatch: Dispatch<actions.PermaURLAction>) {\n  return {\n    setOptionsVisibility: (doShow: boolean) => dispatch(actions.setOptionsVisibility(doShow)),\n    setBackingStore: (newStore: BackingStore) => dispatch(actions.setBackingStore(newStore)),\n  }\n}\n\nfunction mapStateToProps(state: StoreState) {\n  return {\n    optionsState: state.optionsState,\n  }\n}\n\nexport default connect(\n  mapStateToProps,\n  mapDispatchToProps,\n)(PermaURLOptions);\n","import React from 'react';\nimport \"./react-spinner.css\";\n\n// credit to: https://github.com/chenglou/react-spinner\nclass Spinner extends React.Component {\n\n  render() {\n    let bars = [];\n    const props = this.props;\n\n    for (let i = 0; i < 12; i++) {\n      let barStyle = {};\n      barStyle.WebkitAnimationDelay = barStyle.animationDelay =\n        (i - 12) / 10 + 's';\n\n      barStyle.WebkitTransform = barStyle.transform =\n        'rotate(' + (i * 30) + 'deg) translate(146%)';\n\n      bars.push(\n        <div style={barStyle} className=\"react-spinner_bar\" key={i} />\n      );\n    }\n\n    return (\n      <div {...props} className={(props.className || '') + ' react-spinner'}>\n        {bars}\n      </div>\n    );\n  }\n};\n\nexport default Spinner;\n","import React, { Component } from \"react\";\nimport { connect } from \"react-redux\";\nimport { Dispatch } from \"redux\";\n\nimport * as actions from \"./actions/\";\nimport { MissingWeb3Error } from \"./utils/errors\";\nimport { getBackingStoreFromPrefix, getURLForRedirect } from \"./utils/Host\";\nimport Message from \"./containers/Message\";\nimport PermaURLForm from \"./containers/PermaURLForm\";\nimport PermaURLModalDialog from \"./containers/PermaURLModalDialog\";\nimport PermaURLOptions from \"./containers/PermaURLOptions\";\nimport {\n  getFullURLFromHash,\n  getWeb3Components,\n  Permissions\n} from \"./utils/PermaURLUtil\";\nimport Spinner from \"./external/react-spinner/react-spinner\";\nimport {\n  BackingStore,\n  FormState,\n  MessageKind,\n  StoreState,\n  Web3State\n} from \"./types/\";\n\nimport \"./App.css\";\n\ninterface AppProps {\n  backingStore: BackingStore;\n  formState: FormState;\n  isMetamaskDialogVisible: boolean;\n  isSpinnerNeeded: boolean;\n  onMetamaskDialogAcceptClicked: () => void;\n  onMetamaskDialogShouldClose: () => void;\n  onSavedHashToEthereum: (\n    payload: {\n      messageKind: MessageKind;\n      isSpinnerNeeded: boolean;\n      savedHash: string;\n    }\n  ) => void;\n  onSendingHashToEthereum: (\n    payload: {\n      messageKind: MessageKind;\n      isSpinnerNeeded: boolean;\n    }\n  ) => void;\n  updateWeb3State: (newWeb3State: Web3State) => void;\n  updateMessage: (newMessage: MessageKind) => void;\n  web3State: Web3State;\n}\n\ninterface AppState {}\n\nclass App extends Component<AppProps, AppState> {\n  async componentWillMount() {\n    document.title = \"CrispLink: shorten that link!\";\n\n    const locationHash = window.location.hash;\n\n    // locationHash is more than just \"#/\"\n    if (locationHash.length <= 3) {\n      return;\n    }\n    // locationHash must start with \"#<prefix-char>/\"\n    if (locationHash[2] !== \"/\") {\n      return;\n    }\n\n    const backingStore = getBackingStoreFromPrefix(locationHash);\n    if (backingStore === null) {\n      return;\n    }\n\n    const hash = locationHash.substring(3);\n    const fullURL = await getFullURLFromHash(hash, backingStore);\n    if (fullURL === null) {\n      return;\n    }\n    window.location.href = getURLForRedirect(fullURL);\n  }\n\n  render() {\n    return (\n      <div className=\"App\">\n        <header className=\"App-header\">\n          <PermaURLModalDialog\n            isVisible={this.props.isMetamaskDialogVisible}\n            onAcceptButtonClicked={this.onMetamaskDialogAcceptClicked.bind(\n              this\n            )}\n            onDialogShouldClose={this.props.onMetamaskDialogShouldClose}\n          />\n          <PermaURLForm />\n          <PermaURLOptions />\n          <Message />\n          <div> {this.props.isSpinnerNeeded ? <Spinner /> : null} </div>\n        </header>\n      </div>\n    );\n  }\n\n  async onMetamaskDialogAcceptClicked() {\n    this.props.onMetamaskDialogAcceptClicked();\n\n    // ensure web3 is hooked up\n    try {\n      await this.initWeb3();\n    } catch (error) {\n      if (error instanceof MissingWeb3Error) {\n        this.props.updateMessage(MessageKind.INSTALL_METAMASK);\n        return;\n      }\n    }\n\n    let hashedURL = this.props.formState.customHash;\n    if (hashedURL === \"\" || hashedURL === null) {\n      // if user has not specified a desired hash,\n      // then fallback to generating one ourselves\n      let autogeneratedHash = await this.hashFullURL(\n        this.props.formState.fullURL\n      );\n      if (autogeneratedHash === null) {\n        return;\n      }\n      hashedURL = autogeneratedHash;\n    }\n\n    await this.saveToEthereum(hashedURL);\n  }\n\n  async initWeb3() {\n    if (this.props.web3State.web3 !== null) {\n      // already init'd\n      return;\n    }\n\n    const components = await getWeb3Components(\n      Permissions.READ_WRITE,\n      this.props.backingStore\n    );\n    if (components === null) {\n      return;\n    }\n\n    // Set web3, accounts, and contract to the state, and then proceed with an\n    // example of interacting with the contract's methods.\n    this.props.updateWeb3State({\n      web3: components.web3,\n      accounts: components.accounts,\n      contract: components.contract\n    });\n  }\n\n  async hashFullURL(fullURL: string): Promise<string | null> {\n    const bigHash = await this.sha256(fullURL);\n\n    let totalAttempts = 0; // try 10 times and otherwise declare bankruptcy!\n    while (totalAttempts < 10) {\n      const hashedURL = bigHash.substring(0, 3 + totalAttempts);\n      const prevSavedURL = await this.props.web3State.contract.get.call(\n        this.props.web3State.web3.utils.fromAscii(hashedURL)\n      );\n      if (prevSavedURL === null) {\n        return hashedURL;\n      }\n\n      totalAttempts++;\n    }\n\n    this.props.updateMessage(MessageKind.FAILED_TO_GENERATE_HASH);\n    return null;\n  }\n\n  // credit: https://gist.github.com/chrisveness/e5a07769d06ed02a2587df16742d3fdd\n  async sha256(message: string): Promise<string> {\n    // encode as UTF-8\n    const msgUint8 = new TextEncoder().encode(message + Date.now());\n    // hash the message\n    const hashBuffer = await crypto.subtle.digest(\"SHA-256\", msgUint8);\n    // convert hash to byte array\n    const hashArray = Array.from(new Uint8Array(hashBuffer));\n    // convert bytes to hex string\n    const hashHex = hashArray\n      .map(b => (\"00\" + b.toString(16)).slice(-2))\n      .join(\"\");\n    return hashHex;\n  }\n\n  async saveToEthereum(hashedURL: string): Promise<void> {\n    // set loading indicator\n    this.props.onSendingHashToEthereum({\n      messageKind: MessageKind.SENDING_TO_ETHEREUM,\n      isSpinnerNeeded: true\n    });\n\n    // send hash => original to ethereum\n    try {\n      await this.props.web3State.contract.set(\n        this.props.web3State.web3.utils.asciiToHex(hashedURL),\n        this.props.web3State.web3.utils.asciiToHex(\n          this.props.formState.fullURL\n        ),\n        { from: this.props.web3State.accounts[0] }\n      );\n    } catch (e) {\n      console.error(e);\n      this.props.onSendingHashToEthereum({\n        messageKind: MessageKind.ERROR_SENDING_TO_ETHEREUM,\n        isSpinnerNeeded: false\n      });\n      return;\n    }\n\n    this.props.onSavedHashToEthereum({\n      isSpinnerNeeded: false,\n      messageKind: MessageKind.HASHED_URL_WITH_COPY,\n      savedHash: hashedURL\n    });\n  }\n}\n\nfunction mapDispatchToProps(dispatch: Dispatch<actions.PermaURLAction>) {\n  return {\n    onMetamaskDialogShouldClose: () => dispatch(actions.modalCancelClicked()),\n    onMetamaskDialogAcceptClicked: () => dispatch(actions.modalAcceptClicked()),\n    updateWeb3State: (newWeb3State: Web3State) =>\n      dispatch(actions.updateWeb3State(newWeb3State)),\n    updateMessage: (newMessage: MessageKind) =>\n      dispatch(actions.updateMessage(newMessage)),\n\n    onSendingHashToEthereum: (payload: {\n      messageKind: MessageKind;\n      isSpinnerNeeded: boolean;\n    }) => dispatch(actions.onSendingHashToEthereum(payload)),\n    onSavedHashToEthereum: (payload: {\n      messageKind: MessageKind;\n      isSpinnerNeeded: boolean;\n      savedHash: string;\n    }) => dispatch(actions.onSavedHashToEthereum(payload))\n  };\n}\n\nfunction mapStateToProps(state: StoreState) {\n  return {\n    backingStore: state.optionsState.backingStore,\n    formState: state.formState,\n    isMetamaskDialogVisible: state.isMetamaskDialogVisible,\n    isSpinnerNeeded: state.isSpinnerNeeded,\n    web3State: state.web3State\n  };\n}\n\nexport default connect(\n  mapStateToProps,\n  mapDispatchToProps\n)(App);\n","import { combineReducers } from 'redux';\n\nimport * as actions from \"../actions/\"\nimport * as constants from \"../constants\";\nimport {\n  FormState,\n  initFormState,\n  initialState,\n  initWeb3State,\n  MessageKind,\n  OptionsState,\n  initOptionsState,\n  StoreState,\n  Web3State,\n} from \"../types/\";\n\nfunction isMetamaskDialogVisible(\n  state: boolean | undefined = false,\n  action: actions.PermaURLAction,\n): boolean {\n  switch (action.type) {\n    case constants.MODAL_ACCEPT_PRESSED:\n    case constants.MODAL_CANCEL_PRESSED:\n      return false;\n    case constants.SHOW_METAMASK_DIALOG:\n      return true;\n    default:\n      return state;\n  }\n}\n\nfunction web3State(\n  state: Web3State | undefined = initWeb3State,\n  action: actions.PermaURLAction,\n): Web3State {\n  switch (action.type) {\n    case constants.UPDATE_WEB3_STATE:\n      return (action as actions.UpdateWeb3StateAction).web3State;\n    default:\n      return state;\n  }\n}\n\nfunction messageKind(\n  state: MessageKind | undefined = MessageKind.NONE,\n  action: actions.PermaURLAction,\n): MessageKind {\n  switch (action.type) {\n    case constants.ON_HASH_INPUT_CHANGE:\n      return (action as actions.OnHashInputChangeAction).payload.messageKind;\n    case constants.ON_CUSTOM_HASH_CHECK_IS_RESOLVED:\n      return (action as actions.OnCustomHashCheckIsResolvedAction).payload.messageKind;\n    case constants.ON_SAVED_HASH_TO_ETHEREUM:\n      return (action as actions.OnSavedHashToEthereumAction).payload.messageKind;\n    case constants.ON_SENDING_HASH_TO_ETHEREUM:\n      return (action as actions.OnSendingHashToEthereumAction).payload.messageKind;\n    case constants.UPDATE_MESSAGE:\n      return (action as actions.UpdateMessageAction).kind;\n    default:\n      return state;\n  }\n}\n\nfunction formState(\n  state: FormState | undefined = initFormState,\n  action: actions.PermaURLAction,\n): FormState {\n  switch (action.type) {\n    case constants.FULL_URL_CHANGED:\n      return {\n        ...state,\n        fullURL: (action as actions.FullURLChangedAction).text,\n      };\n    case constants.ON_HASH_INPUT_CHANGE:\n      let action2 = action as actions.OnHashInputChangeAction;\n      return {\n        ...state,\n        customHashTimeoutID: action2.payload.customHashTimeoutID,\n        customHash: action2.payload.customHash,\n        isSubmitEnabled: action2.payload.isSubmitEnabled,\n      };\n    case constants.ON_CUSTOM_HASH_CHECK_IS_RESOLVED:\n      let actn = action as actions.OnCustomHashCheckIsResolvedAction;\n      return {\n        ...state,\n        customHash: actn.payload.customHash,\n        customHashTimeoutID: actn.payload.customHashTimeoutID,\n        isSubmitEnabled: actn.payload.isSubmitEnabled,\n      };\n    default:\n      return state;\n  }\n}\n\nfunction savedHash(\n  state: string | null | undefined = null,\n  action: actions.PermaURLAction,\n): string | null {\n  switch (action.type) {\n    case constants.ON_SAVED_HASH_TO_ETHEREUM:\n      return (action as actions.OnSavedHashToEthereumAction).payload.savedHash;\n    default:\n      return state;\n  }\n}\n\nfunction isSpinnerNeeded(\n  state: boolean | undefined = false,\n  action: actions.PermaURLAction,\n): boolean {\n  switch (action.type) {\n    case constants.ON_HASH_INPUT_CHANGE:\n      return (action as actions.OnHashInputChangeAction).payload.isSpinnerNeeded;\n    case constants.ON_CUSTOM_HASH_CHECK_IS_RESOLVED:\n      return (action as actions.OnCustomHashCheckIsResolvedAction).payload.isSpinnerNeeded;\n    case constants.ON_SAVED_HASH_TO_ETHEREUM:\n      return (action as actions.OnSavedHashToEthereumAction).payload.isSpinnerNeeded;\n    case constants.ON_SENDING_HASH_TO_ETHEREUM:\n      return (action as actions.OnSendingHashToEthereumAction).payload.isSpinnerNeeded;\n    default:\n      return state;\n  }\n}\n\nfunction optionsState(\n  state: OptionsState | undefined = initOptionsState,\n  action: actions.PermaURLAction,\n): OptionsState {\n  switch (action.type) {\n      case constants.SET_OPTIONS_VISIBILITY:\n        return {\n          ...state,\n          isVisible: (action as actions.SetOptionsVisibilityAction).doShow,\n        };\n      case constants.SET_BACKING_STORE:\n        return {\n          ...state,\n          backingStore: (action as actions.SetBackingStoreAction).newStore,\n        };\n    default:\n      return state;\n  }\n}\n\nexport const permaURLAppReducers = combineReducers({\n  formState: formState,\n  isMetamaskDialogVisible: isMetamaskDialogVisible,\n  isSpinnerNeeded: isSpinnerNeeded,\n  messageKind: messageKind,\n  optionsState: optionsState,\n  savedHash: savedHash,\n  web3State: web3State,\n});\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read http://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === \"localhost\" ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === \"[::1]\" ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === \"production\" && \"serviceWorker\" in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener(\"load\", () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            \"This web app is being served cache-first by a service \" +\n              \"worker. To learn more, visit http://bit.ly/CRA-PWA\"\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === \"installed\") {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                \"New content is available and will be used when all \" +\n                  \"tabs for this page are closed. See http://bit.ly/CRA-PWA.\"\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log(\"Content is cached for offline use.\");\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error(\"Error during service worker registration:\", error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get(\"content-type\");\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf(\"javascript\") === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        \"No internet connection found. App is running in offline mode.\"\n      );\n    });\n}\n\nexport function unregister() {\n  if (\"serviceWorker\" in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport { Provider } from \"react-redux\";\nimport { createStore } from \"redux\";\n\nimport App from \"./App\";\nimport { permaURLAppReducers } from \"./reducers/\";\nimport * as serviceWorker from \"./serviceWorker\";\nimport { initialState } from \"./types/index\";\n\nimport \"./index.css\";\n\n// store\nconst store = createStore(permaURLAppReducers, initialState);\n\nReactDOM.render(\n  <Provider store={store}>\n    <App />\n  </Provider>,\n  document.getElementById(\"root\")\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: http://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}